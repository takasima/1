#!/usr/bin/perl -w

# Add cron like this, 0,20,40 * * * * cd <path to mt> ./tools/run-backup-sql-and-docs
# When recover database, like this, $/usr/bin/mysql dbname -u user -ppassword < ./mysql.sql
# or $/usr/bin/psql dbname < ./pgsql.sql

# When using PostgreSQL
# $ vi ~/.pgpass
# hostname:portnumber:database:username:password # Default portnumber is 5432.
# $ chmod 600 .pgpass

use strict;
use lib 'lib',    '../lib';
use lib 'extlib', '../extlib';
require MT;
require MT::Builder;
require MT::Template::Context;

use File::Spec;
use File::Basename;
use File::Find;
use File::Copy;
use Cwd;

my $mt = MT->new() or die MT->errstr;
my $app = MT->instance();

my $plugin     = MT->component('BackupConfig');
my $backup_sql = $plugin->get_config_value('backup_sql');
my $backup_doc = $plugin->get_config_value('backup_doc');
if ( ( !$backup_sql ) && ( !$backup_doc ) ) {
    exit;
}
my $driver  = MT->config('ObjectDriver');
my $charset = MT->config('PublishCharset');

unless ( MT->version_number < 5 ) {
    $charset = 'utf8';
}
else {
    $charset = 'utf8' if $charset eq 'UTF-8';
    $charset = 'ujis' if $charset eq 'EUC-JP';
    $charset = 'sjis' if $charset eq 'Shift_JIS';
}

my $sql_file     = $plugin->get_config_value('sql_file');
my $archive_file = $plugin->get_config_value('archive_file');
my $sql2zip      = $plugin->get_config_value('sql2zip');
my $last_backup  = $plugin->get_config_value('last_backup');
$last_backup = 0 unless $last_backup;

my $ctx   = MT::Template::Context->new;
my $build = MT::Builder->new;

my $tokens = $build->compile( $ctx, $sql_file )
    or
    die $app->error( $app->translate( "Parse error: [_1]", $build->errstr ) );

defined( $sql_file = $build->build( $ctx, $tokens ) )
    or
    die $app->error( $app->translate( "Build error: [_1]", $build->errstr ) )
    if $backup_sql;

$tokens = $build->compile( $ctx, $archive_file )
    or
    die $app->error( $app->translate( "Parse error: [_1]", $build->errstr ) );

defined( $archive_file = $build->build( $ctx, $tokens ) )
    or
    die $app->error( $app->translate( "Build error: [_1]", $build->errstr ) )
    if $backup_doc;

my $sqldump       = $plugin->get_config_value('sqldump');
my $backup_root   = $plugin->get_config_value('backup_root');
my @backup_roots  = split( /,/, $backup_root );
my $update_backup = $plugin->get_config_value('update_backup');
my $sqlopt        = $plugin->get_config_value('sqlopt');
my $exclude       = $plugin->get_config_value('exclude');
my @expath        = split( /,/, $exclude );

my $use_ftp       = $plugin->get_config_value('bk_use_ftp');
my $up2server     = $plugin->get_config_value('bk_up2server');
my $ftpcwd        = $plugin->get_config_value('bk_ftpcwd');
my $user_id       = $plugin->get_config_value('bk_user_id');
my $password      = $plugin->get_config_value('bk_ftppassword');
my $remove_at_ftp = $plugin->get_config_value('bk_remove_at_ftp');

my $res;
if ($backup_sql) {
    my $dbname = MT->config('Database');
    my $dbuser = MT->config('DBUser');
    my $passwd = MT->config('DBPassword');
    my $port   = MT->config('DBPort');
    my $host   = MT->config('DBHost');

    my $opt1 = '';
    my $opt2 = '';
    my $opt3 = '';
    my $opt4 = '';

    if ( $driver eq 'DBI::mysql' ) {
        $opt1 = "--default-character-set=$charset" if $charset;
        $opt2 = "-P$port"                          if $port;
        $opt3 = "-h$host"                          if $host;
        $opt4 = "-p$passwd"                        if $passwd;
    }
    elsif ( $driver eq 'DBI::postgres' ) {
        $opt1 = "-p $port" if $port;
        $opt2 = "-h $host" if $host;
    }

    $sqlopt = '' unless $sqlopt;
    my $cmd = "";
    if ( $driver eq 'DBI::mysql' ) {
        if ( ( eval 'use Win32; 1' ) ) {
            $cmd
                = qq/"$sqldump" $opt1 --compact $sqlopt $dbname -u $dbuser $opt2 $opt3 $opt4 --add-drop-table > $sql_file/;
        }
        else {
            $cmd
                = "$sqldump $opt1 --compact $sqlopt $dbname -u $dbuser $opt2 $opt3 $opt4 --add-drop-table > '$sql_file'";
        }
    }
    elsif ( $driver eq 'DBI::postgres' ) {
        $cmd
            = "$sqldump --username=$dbuser $opt1 $opt2 $dbname > '$sql_file'";
    }
    elsif ( $driver eq 'DBI::oracle' ) {
        $cmd = "$sqldump $sqlopt $dbuser/$passwd" . '@'
            . "$dbname file='$sql_file'";
    }
    elsif ( $driver eq 'DBI::mssqlserver' ) {
        $cmd
            = qq/$sqlopt -Q "USE master; BACKUP DATABASE $dbname TO DISK='$sql_file';"/;
    }

    if ( $driver eq 'DBI::mssqlserver' ) {
        if ( ( eval 'use Win32; 1' ) && ( eval 'use Win32::Process; 1' ) ) {
            my $ProcessObj;

            sub ErrorReport {
                MT->log( Win32::FormatMessage( Win32::GetLastError() ) );
            }
            Win32::Process::Create( $ProcessObj, $sqldump, $cmd, 0,
                0x00000020, "." )
                || die MT->log( ErrorReport() );
            $ProcessObj->Suspend();
            $ProcessObj->Resume();
            $ProcessObj->Wait(0xFFFFFFFF);
        }
    }
    else {
        $res = system($cmd )
            if ( ($cmd)
            && ($sqldump)
            && ($dbname)
            && ($dbuser)
            && ($sql_file) );
    }

    if ( -f $sql_file ) {
        my $ts   = ( stat $sql_file )[9];
        my $size = ( stat $sql_file )[7];
        if ( ($size) && ( ( time - $ts ) < 10 ) ) {
            $app->log(
                $plugin->translate('SQL database successfully backed up.') );
            $res = 1;
        }
    }
    unless ($res) {
        $app->log( $plugin->translate('SQL database back up failed.') );
    }
}

my $archiver = 'zip';
eval { require Archive::Zip };
if ($@) {
    eval { require Archive::Tar };
    $archiver = 'tar';
    die $app->log(
        $plugin->translate(
            'Neither Archive::Zip nor Archive::Tar is available.')
    ) if $@;
}

if ( $archiver eq 'zip' ) {
    if ($backup_sql) {
        if ($sql2zip) {
            if ($res) {
                my $zip = Archive::Zip->new();
                my $filename = fileparse( $sql_file, () );
                $zip->addFile( $sql_file, $filename );
                $zip->writeToFileNamed("$sql_file.zip");
                if ( -f "$sql_file.zip" ) {
                    unlink $sql_file;
                    $sql_file = "$sql_file.zip";
                }
            }
        }
        if ( $archive_file !~ /\.zip$/ ) {
            $archive_file .= '.zip';
        }
    }
}
else {
    if ( $archive_file !~ /\.tar$/ ) {
        $archive_file .= '.tar';
    }
}

my $archived;
my $backup;

if ($backup_doc) {
    if ($backup_root) {
        my $archive;
        if ( $archiver eq 'zip' ) {
            $archive = Archive::Zip->new();
        }
        else {
            $archive = Archive::Tar->new();
        }
        $plugin->set_config_value( 'last_backup', time );
        my $cwd = cwd();
        for my $backup_root (@backup_roots) {
            next unless ( -d $backup_root );
            my $abs_path = File::Spec->abs2rel( $backup_root, $cwd );
            my @directories_to_search = ($abs_path);
            my @wantedFiles;
            find( sub { push( @wantedFiles, $File::Find::name ); },
                @directories_to_search );
            my $q_abs = quotemeta($abs_path);
            for my $f (@wantedFiles) {
                if ( -f $f ) {
                    $f =~ s/^$q_abs//;
                    $f = File::Spec->catdir( $backup_root, $f );
                    my $no_archive;
                    for my $exclude (@expath) {
                        if ( $f =~ /$exclude/ ) {
                            $no_archive = 1;
                            next;
                        }
                    }
                    if ($update_backup) {
                        my $ts = ( stat $f )[9];
                        if ( $ts <= $last_backup ) {
                            $no_archive = 1;
                        }
                    }
                    unless ($no_archive) {
                        $archived = 1;
                        if ( $archiver eq 'zip' ) {
                            my $file = $f;
                            if ( ( scalar(@backup_roots) ) == 1 ) {
                                my $q_backup_root = quotemeta($backup_root);
                                $file =~ s/$q_backup_root//;
                                if ( $file =~ /^\// ) {
                                    $file = substr( $file, 1, length($file) );
                                }
                            }
                            $archive->addFile( $f, $file );
                        }
                        else {
                            $archive->add_files($f);
                        }
                    }
                }
            }
        }
        if ($archived) {
            if ( $archiver eq 'zip' ) {
                $backup = $archive->writeToFileNamed($archive_file);
            }
            else {
                $backup = $archive->write($archive_file);
            }
            if ( !-f $archive_file ) {
                $backup = 0;
            }
            else {
                my $size = ( stat $archive_file )[7];
                unless ($size) {
                    $backup = 0;
                }
                else {
                    $backup = 1;
                }
            }
        }
        if ( ($backup) && ($archived) ) {
            $app->log(
                $plugin->translate(
                    'Web document root successfully backed up.')
            );
        }
        if ( ( !$backup ) && ($archived) ) {
            $app->log(
                $plugin->translate('Web document root back up failed.') );
        }
        if ($update_backup) {
            if ( !$archived ) {
                $app->log(
                    $plugin->translate('No back up files was found.') );
            }
        }
    }
}

if ($use_ftp) {
    eval { require Net::FTP };
    if ($@) {
        die $app->log( $plugin->translate('Net::FTP is not available.') );
    }
    use Net::FTP;
    my $ftp = Net::FTP->new($up2server);
    my $login = $ftp->login( $user_id, $password )
        or die $app->log( $plugin->translate('FTP login failed.') );
    $ftp->binary;
    if ($ftpcwd) {
        my $chdir = $ftp->cwd($ftpcwd);
        unless ($chdir) {
            die $app->log( $plugin->translate('FTP CWD command failed.') );
        }
    }
    if ($backup_sql) {
        my $fname = fileparse( $sql_file, () );
        my $put = $ftp->put($sql_file);
        if ( $fname eq $put ) {
            $app->log( $plugin->translate('FTP put SQL file successfull.') );
            unlink $sql_file if $remove_at_ftp;
        }
        else {
            $app->log('FTP put SQL file failed.');
        }
    }
    if ($backup_doc) {
        if ($backup_root) {
            if ( ($backup) && ($archived) ) {
                my $fname = fileparse( $archive_file, () );
                my $put = $ftp->put($archive_file);
                if ( $fname eq $put ) {
                    $app->log(
                        $plugin->translate(
                            'FTP put backup file of web document root successfull.'
                        )
                    );
                    unlink $archive_file if $remove_at_ftp;
                }
                else {
                    $app->log(
                        $plugin->translate(
                            'FTP put backup file of web document root failed.'
                        )
                    );
                }
            }
        }
    }
    $ftp->quit;
}

$app->log( $plugin->translate('All back up process successfull.') );

1;
