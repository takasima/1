#!/usr/bin/perl
package MT::Tool::RebuildArchives;
use strict;
use warnings;
use File::Spec;
use FindBin;
use lib map File::Spec->catdir($FindBin::Bin, File::Spec->updir, $_), qw/lib extlib/;
use base qw( MT::Tool );

sub usage { '[--at <comma,separated,archive_types>] [--blog_id <comma,separated,blog_ids>]' }

sub help {
    return q {
        Rebuild blog by archive types.

        --at <comma,separated,archive_types>
                      Optional: Index,Monthly,Individual,Category...
        --blog_id <comma,separated,blog_ids>
                      Optional: 1,2,3...
        --sleep <integer>
                      Optional: default => 0
        --debug <integer>
                      Optional: default => 0

    };
}

my ( $at, $blog_id, $sleep, $debug );

sub options {
    return (
        'at=s'      => \$at,
        'blog_id=s' => \$blog_id,
        'sleep=s'   => \$sleep,
        'debug=s'   => \$debug,
    );
}

sub default_archive_types {
    my @ats = qw( index
                  Daily Monthly Weekly Yearly 
                  Author Category 
                  AuthorDaily AuthorMonthly AuthorWeekly AuthorYearly
                  CategoryDaily CategoryMonthly CategoryWeekly CategoryYearly
                  Page Individual
                  Date
                );
    return wantarray ? @ats : \@ats;
}

sub main {
    my $class = shift;
    my ( $verbose ) = $class->SUPER::main( @_ );
    my @ats;
    my $terms;
    if ( $at ) {
        @ats = split( /,/, $at );
        $terms->{ archive_type } = \@ats;
    }
    my @blog_ids;
    if ( $blog_id ) {
        @blog_ids = split( /,/, $blog_id );
        $terms->{ blog_id } = \@blog_ids;
    }
    require MT::FileInfo;
    require MT::TemplateMap;
    require MT::Template;
    require MT::WeblogPublisher;
    my $pub = MT::WeblogPublisher->new;
    my $iter = MT::FileInfo->load_iter( $terms );
    my @default_archive_types = default_archive_types();
    while ( my $fi = $iter->() ) {
        next if $fi->has_column( 'original_id' ) && $fi->original_id; # for Pager
        if (! $fi->virtual ) {
            my $map_id = $fi->templatemap_id;
            my $tmpl_id = $fi->template_id;
            if ( $map_id ) {
                my $map = MT::TemplateMap->load( $map_id );
                if ( $map ) {
                    next unless $map->build_type;
                }
                if ( $tmpl_id ) {
                    my $tmpl = MT::Template->load( $tmpl_id );
                    if ( $tmpl ) {
                        next unless $tmpl->build_type;
                        next if $tmpl->type eq 'backup';
                    } else {
                        next;
                    }
                }
            } elsif ( $tmpl_id ) {
                my $tmpl = MT::Template->load( $tmpl_id );
                if ( $tmpl ) {
                    next unless $tmpl->build_type;
                    next if $tmpl->type eq 'backup';
                } else {
                    next;
                }
            }
            if ( grep { $fi->archive_type eq $_ } @default_archive_types ) {
                print $fi->archive_type . ': ' . $fi->file_path . "\n" if $debug;
                $pub->rebuild_from_fileinfo( $fi );
            } else {
                if ( $fi->archive_type eq 'FolderCustomObject' ) {
                    my $folder = MT->model( 'folder' )->load( $fi->category_id );
                    my $blog = MT->model( 'blog' )->load( $fi->blog_id );
                    if ( $folder ) {
                        print $fi->archive_type . ': ' . $fi->file_path . "\n" if $debug;
                        require ArchiveType::FolderCustomObject;
                        ArchiveType::FolderCustomObject::rebuild_folder( MT->instance, $blog, $fi->archive_type, $folder );
                    }
                }
            }
            if ( $sleep ) {
                sleep $sleep;
            }
        }
    }
    1;
}

__PACKAGE__->main() unless caller;
